<!DOCTYPE html>
<html>
    <head>
        <style>
            #workingbox {
                border-style: solid;
                height: fit-content;
                width: fit-content;                
                text-align: center;
                margin: auto;
                margin-top: 10px;
                margin-bottom: 10px;
                padding: 10px;
            }
        </style>
    </head>
    <body style="text-align: center;">
        <h2>R Critical, Damping Ratio & Q Factor Calculation</h2>
        <div>
            <form id="entries" oninput="workout()">
                <label for="R">R_crit(Ohm)</label>
                <input type='number' id='R'>
                <label for="L">L(mH)</label>
                <input type='number' id='L'>
                <label for="C">C(nF)</label>
                <input type='number' id='C'>
                <button type="reset">Reset</button>
            </form>
        </div>
        <h3>Working Out</h3>
        <div id="workingbox" style='border-color:gray;'>
            <span id='working'></span>
        </div>
        <br><br><br>
        <h3>Information</h3>
        <ul>
            <li>Filling in 2 of the fields will trigger the calculation of the third value</li>
            <li>Filling in all fields will calculate Damping Ratio and Quality Factor, R_crit will be treated as resistance</li>
            <li>Use series if 2ODE in terms of i, parallel if in terms of v</li>
        </ul>
    </body>
    <script>
        var working = document.getElementById('working');
        function workout(){
            let R = parseFloat(document.getElementById('R').value);
            let L = parseFloat(document.getElementById('L').value)*0.001;
            let C = parseFloat(document.getElementById('C').value)*0.000000001;
            let nanCount=isNaN(R)+2*isNaN(L)+3*isNaN(C);
            switch(nanCount){
                case 0:
                    //Damping Ratio & Q Factor
                    working.innerHTML = "Damping Ratio<br><br>Series:<br>ζ = R/2 * sqrt(C/L)<br>= "+R+"/2 * sqrt("+sigfig(C)+"/"+sigfig(L)+") = "+sigfig(R/2*Math.sqrt(C/L))+"<br><br>Parallel:<br>ζ = 1/(2R) * sqrt(L/C)<br>= 1/(2"+R+") * sqrt("+sigfig(L)+"/"+sigfig(C)+") = "+sigfig(1/R/2*Math.sqrt(L/C))+"<br><br><br>Q Factor<br><br>Series:<br>Q = 1/R * sqrt(L/C)<br>= 1/"+R+" * sqrt("+sigfig(L)+"/"+sigfig(C)+") = "+sigfig(1/R*Math.sqrt(L/C))+"<br><br>Parallel:<br>Q = R * sqrt(C/L)<br>= "+R+" * sqrt("+sigfig(C)+"/"+sigfig(L)+") = "+sigfig(R*Math.sqrt(C/L));
                    break;
                case 1:
                    //Resistor
                    working.innerHTML = "Resistor<br><br>Series:<br>R_crit = 2 * sqrt(L/C)<br>= 2 * sqrt("+sigfig(L)+"/"+sigfig(C)+") = "+sigfig(2*Math.sqrt(L/C)) + " Ohms<br><br>Parallel:<br>R_crit = 0.5 * sqrt(L/C)<br>= 0.5 * sqrt("+sigfig(L)+"/"+sigfig(C)+") = "+sigfig(0.5*Math.sqrt(L/C)) + " Ohms";
                    break;
                case 2:
                    //Inductor
                    working.innerHTML = "Inductor<br><br>Series:<br>L = C*(R_crit/2)^2 = <br>= "+sigfig(C)+"*("+R+"/2)^2 = "+sigfig(C*(R*R/4)*1000) + " mH<br><br>Parallel:<br>L = C*(R_crit*2)^2 = <br>= "+sigfig(C)+"*("+R+"*2)^2 = "+sigfig(C*(R*R*4)*1000) + " mH";
                    break;
                case 3:
                    //Capacitor
                    working.innerHTML = "Capacitor<br><br>Series:<br>L = L/(R_crit/2)^2 = <br>= "+sigfig(L)+"/("+R+"/2)^2 = "+sigfig(L/(R*R/4)*1000000000) + " nF<br><br>Parallel:<br>L = L/(R_crit*2)^2 = <br>= "+sigfig(L)+"/("+R+"*2)^2 = "+sigfig(L/(R*R*4)*1000000000) + " nF"
                    break;
            }
        }
        function sigfig(num, sf=4){
            let output = parseFloat(num.toPrecision(sf));
            return output;
        }
        function add(num){
            return num >= 0 ? "+ "+num : "- "+(-num);
        }
        function angle(ma){
            if (isNaN(ma[1])){
                return ma[0];
            }
            return sigfig(ma[0])+" ∠ "+sigfig(ma[1])+"°";
        }
        function toPhasor(A,B){
            let m = Math.sqrt(A*A+B*B);
            let angle = Math.atan(B/A)/Math.PI*180;
            return [m,angle];
        }
        function complexInv(Re,Im){
            let denominator = Re*Re + Im*Im;
            return [Re/denominator,-Im/denominator];
        }
    </script>
</html>